#include "limp_app.hpp"
#include "limp_processor.hpp"
#include "version.hpp"
#include <be/core/logging.hpp>
#include <be/core/version.hpp>
#include <be/util/version.hpp>
#include <be/blt/version.hpp>
#include <be/core/alg.hpp>
#include <be/util/path_glob.hpp>
#include <be/cli/cli.hpp>
#include <be/belua/log_exception.hpp>
#include <be/core/log_exception.hpp>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

namespace be {
namespace limp {

///////////////////////////////////////////////////////////////////////////////
LimpApp::LimpApp(int argc, char** argv) {
   default_log().verbosity_mask(v::info_or_worse);
   init_default_langs_();
   try {
      using namespace cli;
      using namespace color;
      using namespace ct;
      Processor proc;

      bool show_version = false;
      bool show_help = false;
      bool verbose = false;
      S help_query;

      proc
         (prologue (Table() << header << "LIMP").query())

         (synopsis (Cell() << fg_dark_gray << "[ " << fg_cyan << "OPTIONS"
                           << fg_dark_gray << " ] [ " << fg_cyan << "INPUT"
                           << fg_dark_gray << " [ " << fg_cyan << "INPUT"
                           << fg_dark_gray << " ...]]"))

         (abstract ("The Lua Inline Metaprogramming Processor (LIMP) looks for specially constructed comments in source code, "
                    "executes them as Lua scripts, and inserts or replaces the results in the original source file."))

         (summary ("For each input file, LIMP will look for comments that contain '!!' immediately following the "
                   "comment opener.  It will then treat the comment as Lua code until it encounters another '!!' sequence or "
                   "the end of the comment.  If it finds a second '!!', it will try to interpret the remaining characters as "
                   "an integer, indicating the number of lines following the comment which were previously generated by LIMP.  "
                   "These lines will be replaced by any lines generated by the Lua code.").verbose())

         (summary ("The sequences of characters that are treated as comment openers and closers can be customized by creating a "
                   ".limpconf file in the directory that contains the limp executable.  Blank lines and lines that begin with "
                   "'#' are ignored.  Otherwise, each line must have exactly 3 tokens separated by whitespace.  The first is the "
                   "file extension for which the line applies (without the leading '.').  The second token is a sequence of "
                   "characters that denotes the start of a comment, and the last is one that end a comment.  If the same "
                   "extension is specified multiple times, only the last one is valid.  If a line is specified for the extension "
                   "'!!', it overrides the default '!!' tokens that indicate the start and end of Lua code.").verbose())

         (summary ("Note: LIMP does not do any Lua syntax parsing when looking for the LIMP and/or comment end tokens.  In "
                   "particular '!!' will be found even if it is inside a Lua string literal.").verbose())

         (summary ("When there are multiple input files being processed, a new Lua environment is constructed for each input "
                   "file that is processed.  The order that files are processed is undefined.").verbose())

         (summary ("If there are multiple LIMP comments in the same file, they will be processed sequentially, using the same "
                   "environment for all comments (but each comment is loaded as a separate chunk, so they do not share locals).").verbose())

         (summary ("For each Lua environment that is created, the working directory will be set to the parent directory of the "
                   "file being processed.  If that directory contains a .limprc file, it will be loaded and executed.  Otherwise "
                   "the parent directory chain will be recursively searched until a .limprc file is found and executed or the "
                   "filesystem root is reached.").verbose())

         // TODO --watch

         (flag({ "f" },{ "force" }, force_process_).desc("Always process files, even if they haven't changed since last being processed."))
         (flag({ "h" },{ "hash" }, write_hashes_).desc("Output the hash of any processed files to a .limphash file so that they can be skipped when unchanged."))
         (flag({ "n" },{ "dry-run" }, dry_run_).desc("Makes no changes, but reports which files would be changed if run without this option."))
         (flag({ "b" },{ "break-on-fail" }, stop_on_failure_).desc("Stops processing additional inputs after the first failure."))
         (flag({ "R" },{ "recursive" }, recursive_).desc("Recursively looks in subdirectories for files matching the input filenames."))

         (param ({ "D" },{ "input-dir" }, "PATH", [&](const S& str) {
               util::parse_multi_path(str, search_paths_);
            }).desc("Specifies a search path in which to search for input files.")
              .extra(Cell() << nl << "Multiple input directories may be specified by separating them with ';' or ':', or by using multiple "
                            << fg_yellow << "--input-dir" << reset
                            << " options.  Directories will be searched in the order they are specified.  If no input directories "
                               "are specified, the working directory is implicitly searched."))

         (param ({ },{ "depfile" }, "PATH", [&](const S& str) {
               depfile_path_ = fs::absolute(util::parse_path(str));
               if (fs::exists(depfile_path_)) {
                  depfile_path_ = fs::canonical(depfile_path_);
               }
            }).desc("Outputs included scripts and templates to a dependency file.")
              .extra(Cell() << nl << "The output is in a makefile format similar to that generated by " << fg_blue << "gcc " << fg_yellow << "-MMD"
                            << reset << ".  If a relative path is specified, it will be considered relative to the current working directory."))

         (flag({ },{ "test" }, test_).desc("Ignores other options, outputs nothing, and returns status code 0."))

         (any ([&](const S& str) {
            jobs_.push_back(str);
            return true;
         }))

         (end_of_options ())

         (verbosity_param ({ "v" },{ "verbosity" }, "LEVEL", default_log().verbosity_mask()))

         (flag ({ "V" },{ "version" }, show_version).desc("Prints version information to standard output."))

         (param ({ "?" },{ "help" }, "OPTION",
            [&](const S& value) {
               show_help = true;
               help_query = value;
            }).default_value(S())
              .allow_options_as_values(true)
              .desc(Cell() << "Outputs this help message.  For more verbose help, use " << fg_yellow << "--help")
              .extra(Cell() << nl << "If " << fg_cyan << "OPTION" << reset
                            << " is provided, the options list will be filtered to show only options that contain that string."))

         (flag ({ },{ "help" }, verbose).ignore_values(true))

         (exit_code (0, "There were no errors."))
         (exit_code (1, "An unknown error occurred."))
         (exit_code (2, "There was a problem parsing the command line arguments."))
         (exit_code (3, "There was a problem processing an input file."))
         ;

      proc.process(argc, argv);

      if (test_) {
         return;
      }

      if (!show_help && !show_version && jobs_.empty()) {
         show_help = true;
         show_version = true;
         status_ = 1;
      }

      if (show_version) {
         proc
            (prologue(BE_LIMP_VERSION_STRING).query())
            (prologue(BE_BLT_VERSION_STRING).query())
            (prologue(BE_UTIL_VERSION_STRING).query())
            (prologue(BE_CORE_VERSION_STRING).query())
            (prologue(LUA_RELEASE).query())
            (license (BE_LICENSE).query())
            (license (BE_COPYRIGHT).query())
            (license (LUA_COPYRIGHT).query())
            ;
      }

      if (show_help) {
         proc.describe(std::cout, verbose, help_query);
      } else if (show_version) {
         proc.describe(std::cout, verbose, ids::cli_describe_section_prologue);
         proc.describe(std::cout, verbose, ids::cli_describe_section_license);
      }

   } catch (const cli::OptionError& e) {
      status_ = 2;
      log_exception(e);
   } catch (const cli::ArgumentError& e) {
      status_ = 2;
      log_exception(e);
   } catch (const FatalTrace& e) {
      status_ = 2;
      log_exception(e);
   } catch (const RecoverableTrace& e) {
      status_ = 2;
      log_exception(e);
   } catch (const fs::filesystem_error& e) {
      status_ = 2;
      log_exception(e);
   } catch (const std::system_error& e) {
      status_ = 2;
      log_exception(e);
   } catch (const std::exception& e) {
      status_ = 2;
      log_exception(e);
   }
}

///////////////////////////////////////////////////////////////////////////////
int LimpApp::operator()() {
   if (status_ != 0) {
      return status_;
   }

   if (test_) {
      return status_;
   }

   try {
      load_langs_();

      if (search_paths_.empty()) {
         search_paths_.push_back(util::cwd());
      }

      for (const auto& p : search_paths_) {
         be_short_verbose() << "Search path: " << color::fg_gray << p.generic_string() | default_log();
      }

      for (auto& job : jobs_) {
         get_paths_(job);
      }

      for (auto& p : paths_) {
         process_(fs::absolute(p));
         if (stop_on_failure_ && status_ != 0) {
            break;
         }
      }

   } catch (const FatalTrace& e) {
      status_ = std::max(status_, (I8)1);
      log_exception(e);
   } catch (const RecoverableTrace& e) {
      status_ = std::max(status_, (I8)1);
      log_exception(e);
   } catch (const fs::filesystem_error& e) {
      status_ = std::max(status_, (I8)1);
      log_exception(e);
   } catch (const std::system_error& e) {
      status_ = std::max(status_, (I8)1);
      log_exception(e);
   } catch (const std::exception& e) {
      status_ = std::max(status_, (I8)1);
      log_exception(e);
   }

   return status_;
}

///////////////////////////////////////////////////////////////////////////////
void LimpApp::init_default_langs_() {
   {
      LanguageConfig& cfg = langs_[""];
      cfg.opener = "/*";
      cfg.closer = "*/";
   }
   {
      LanguageConfig& cfg = langs_["lua"];
      cfg.opener = "--[==[";
      cfg.closer = "]==]";
   }
   {
      LanguageConfig& cfg = langs_["ninja"];
      cfg.opener = "#";
      cfg.closer = "##";
   }
   {
      LanguageConfig& cfg = langs_["sh"];
      cfg.opener = "#";
      cfg.closer = "##";
   }
   {
      LanguageConfig& cfg = langs_["bat"];
      cfg.opener = "rem ";
      cfg.closer = "##";
   }
   {
      LanguageConfig& cfg = langs_["cmd"];
      cfg.opener = "rem ";
      cfg.closer = "##";
   }
   {
      LanguageConfig& cfg = langs_["xml"];
      cfg.opener = "<!--";
      cfg.closer = "-->";
   }
   {
      LanguageConfig& cfg = langs_["html"];
      cfg.opener = "<!--";
      cfg.closer = "-->";
   }
   {
      LanguageConfig& cfg = langs_["htm"];
      cfg.opener = "<!--";
      cfg.closer = "-->";
   }
   {
      LanguageConfig& cfg = langs_["sql"];
      cfg.opener = "--";
      cfg.closer = "--";
   }
   {
      LanguageConfig& cfg = langs_["!!"];
      cfg.opener = "!!";
      cfg.closer = "!!";
   }
}

///////////////////////////////////////////////////////////////////////////////
void LimpApp::load_langs_() {
   Path limpconf_path = util::default_special_path(util::SpecialPath::install);
   limpconf_path /= ".limpconf";

   if (fs::exists(limpconf_path)) {
      be_short_verbose() << "Loading .limpconf: " << color::fg_gray << limpconf_path.generic_string() | default_log();

      std::ifstream ifs;
      ifs.exceptions(std::ios_base::goodbit);
      ifs.open(limpconf_path.native());
      if (!ifs) {
         be_short_warn() << ".limpconf exists, but could not be opened for reading!" | default_log();
         return;
      }

      S line;
      while(std::getline(ifs, line)) {
         bool comment = true;
         for (char c : line) {
            if (c < ' ') {
               continue;
            }
            if (c == '#') {
               break;
            }
            comment = false;
            break;
         }

         if (!comment) {
            std::istringstream iss(line);
            iss.exceptions(std::ios_base::goodbit);
            S lang, open, close;
            iss >> lang >> open >> close;
            if (!iss) {
               be_warn() << "Ignoring invalid .limpconf line!"
                  & attr(ids::log_attr_found) << S(line)
                  | default_log();

               continue;
            }

            be_verbose() << "Language configured"
               & attr(ids::log_attr_name) << S(lang)
               & attr(ids::log_attr_keyword) << S(open)
               & attr(ids::log_attr_keyword) << S(close)
               | default_log();

            langs_[lang] = LanguageConfig { open, close };
         }
      }
   }
}

///////////////////////////////////////////////////////////////////////////////
void LimpApp::get_paths_(const S& pathspec) {
   be_short_verbose() << "Expanding input path: " << color::fg_gray << S(pathspec) | default_log();

   util::PathMatchType mode = recursive_ ? util::PathMatchType::recursive_files_and_misc : util::PathMatchType::files_and_misc;
   std::vector<Path> paths = util::glob(pathspec, search_paths_, mode);
   for (const Path& p : paths) {
      Path absolute = fs::canonical(p);

      bool inserted = false;
      std::tie(std::ignore, inserted) = paths_.insert(absolute);

      if (inserted) {
         be_short_verbose() << "Match: " << color::fg_gray << absolute.generic_string() | default_log();
      } else {
         be_short_verbose() << "Match: " << color::fg_gray << absolute.generic_string() << color::reset << " (already queued)" | default_log();
      }
   }
}

///////////////////////////////////////////////////////////////////////////////
void LimpApp::process_(const Path& path) {
   try {
      S lang = path.extension().generic_string().substr(1);

      be_short_verbose() << "Processing " << S(lang) << " file: " << color::fg_gray << path.generic_string() | default_log();

      auto it = langs_.find(lang);
      const auto& comment = (it == langs_.end()) ? langs_[""] : it->second;
      const auto& limp = langs_["!!"];
      LimpProcessor proc(path, comment, limp, depfile_path_);

      if (!proc.processable()) {
         proc.clear_hash();
         return;
      }

      if (proc.should_process() || force_process_) {
         Path current_cwd = util::cwd();
         Path new_cwd = path.parent_path();
         if (current_cwd != new_cwd) {
            util::cwd(new_cwd);
         }

         if (proc.process()) {
            if (dry_run_) {
               be_short_info() << "Out of date: " << color::fg_red << path.generic_string() | default_log();
            } else {
               be_short_info() << "Rewriting: " << color::fg_yellow << path.generic_string() | default_log();
               proc.write();
               if (write_hashes_) {
                  proc.write_hash();
               }
            }
         } else {
            if (dry_run_) {
               be_short_info() << "Up to date: " << color::fg_green << path.generic_string() | default_log();
            } else {
               if (write_hashes_ && proc.write_hash()) {
                  be_short_verbose() << "Hash update: " << color::fg_green << path.generic_string() | default_log();
               } else {
                  be_short_verbose() << "Up to date: " << color::fg_green << path.generic_string() | default_log();
               }
            }
         }
      } else if (dry_run_) {
         be_short_info() << "Up to date: " << color::fg_green << path.generic_string() | default_log();
      }

   } catch (const belua::LuaTrace& e) {
      status_ = std::max(status_, (I8)3);
      log_exception(e);
   } catch (const belua::LuaError& e) {
      status_ = std::max(status_, (I8)3);
      log_exception(e);
   } catch (const FatalTrace& e) {
      status_ = std::max(status_, (I8)3);
      log_exception(e);
   } catch (const RecoverableTrace& e) {
      status_ = std::max(status_, (I8)3);
      log_exception(e);
   } catch (const fs::filesystem_error& e) {
      status_ = std::max(status_, (I8)3);
      log_exception(e);
   } catch (const std::system_error& e) {
      status_ = std::max(status_, (I8)3);
      log_exception(e);
   } catch (const std::exception& e) {
      status_ = std::max(status_, (I8)3);
      log_exception(e);
   }
}

} // be::limp
} // be
